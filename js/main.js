//@ sourceMappingURL=main.map
// Generated by CoffeeScript 1.6.1

(function(win, doc, exports) {
  var ANGLE, Camera, DEG_TO_RAD, M22, M44, Mesh, PI, Particle, Quaternion, Renderer, Scene, Texture, Vector3, cos, drawTriangle, makeRotatialQuaternion, sin, tan;
  tan = Math.tan, cos = Math.cos, sin = Math.sin, PI = Math.PI;
  DEG_TO_RAD = PI / 180;
  ANGLE = PI * 2;
  drawTriangle = function(g, img, vertex_list, uv_list) {
    var Ax, Ay, Bx, By, a, b, c, d, height, m, mi, width, _Ax, _Ay, _Bx, _By;
    width = img.width;
    height = img.height;
    _Ax = vertex_list[2] - vertex_list[0];
    _Ay = vertex_list[3] - vertex_list[1];
    _Bx = vertex_list[4] - vertex_list[0];
    _By = vertex_list[5] - vertex_list[1];
    if (((_Ax * (vertex_list[5] - vertex_list[3])) - (_Ay * (vertex_list[4] - vertex_list[2]))) < 0) {
      return;
    }
    Ax = (uv_list[2] - uv_list[0]) * width;
    Ay = (uv_list[3] - uv_list[1]) * height;
    Bx = (uv_list[4] - uv_list[0]) * width;
    By = (uv_list[5] - uv_list[1]) * height;
    m = new M22();
    m._11 = Ax;
    m._12 = Ay;
    m._21 = Bx;
    m._22 = By;
    mi = m.getInvert();
    if (!mi) {
      return;
    }
    a = mi._11 * _Ax + mi._12 * _Bx;
    c = mi._21 * _Ax + mi._22 * _Bx;
    b = mi._11 * _Ay + mi._12 * _By;
    d = mi._21 * _Ay + mi._22 * _By;
    g.save();
    g.beginPath();
    g.moveTo(vertex_list[0], vertex_list[1]);
    g.lineTo(vertex_list[2], vertex_list[3]);
    g.lineTo(vertex_list[4], vertex_list[5]);
    g.clip();
    g.transform(a, b, c, d, vertex_list[0] - (a * uv_list[0] * width + c * uv_list[1] * height), vertex_list[1] - (b * uv_list[0] * width + d * uv_list[1] * height));
    g.drawImage(img, 0, 0);
    return g.restore();
  };
  /**
      Camera class
      @constructor
      @param {number} fov Field of view.
      @param {number} aspect Aspect ratio.
      @param {number} near Near clip.
      @param {number} far far clip.
      @param {Vector3} position Position vector.
  */

  Camera = (function() {

    function Camera(fov, aspect, near, far, position) {
      this.fov = fov;
      this.aspect = aspect;
      this.near = near;
      this.far = far;
      this.position = position != null ? position : new Vector3(0, 0, 20);
      this.viewMatrix = M44.translate(this.position);
      this.worldMatrix = new M44;
      this.projectionMatrix = new M44;
      this.updateProjectionMatrix();
    }

    Camera.prototype.setWorld = function(m) {
      return this.worldMatrix = m;
    };

    Camera.prototype.getProjectionMatrix = function() {
      var tmp;
      tmp = M44.mul(this.viewMatrix, this.projectionMatrix);
      return M44.mul(this.worldMatrix, tmp);
    };

    Camera.prototype.updateProjectionMatrix = function() {
      this.viewMatrix = M44.translate(this.position);
      return this.projectionMatrix.perspectiveLH(this.fov, this.aspect, this.near, this.far);
    };

    return Camera;

  })();
  Texture = (function() {

    function Texture(uv_data, uv_list) {
      this.uv_data = uv_data;
      this.uv_list = uv_list;
    }

    return Texture;

  })();
  Mesh = (function() {

    function Mesh(vertex, texture) {
      this.vertex = vertex;
      this.texture = texture;
    }

    return Mesh;

  })();
  Particle = (function() {

    function Particle(v, sp, size, r, g, b) {
      this.v = v;
      this.sp = sp != null ? sp : 1;
      this.size = size != null ? size : 1000;
      this.r = r != null ? r : 255;
      this.g = g != null ? g : 255;
      this.b = b != null ? b : 255;
      this.vec = new Vector3(1, 0, 1);
    }

    Particle.prototype.update = function() {
      var p, q, r, rad;
      p = new Quaternion(0, this.v);
      rad = this.sp * DEG_TO_RAD;
      q = makeRotatialQuaternion(rad, this.vec);
      r = makeRotatialQuaternion(-rad, this.vec);
      p = r.multiply(p);
      p = p.multiply(q);
      return this.v = p.v;
    };

    return Particle;

  })();
  Scene = (function() {

    function Scene() {
      this.materials = [];
    }

    Scene.prototype.add = function(material) {
      return this.materials.push(material);
    };

    Scene.prototype.sort = function(func) {
      if (func) {
        return this.materials.sort(func);
      }
    };

    Scene.prototype.each = function(func) {
      if (func) {
        return this.materials.forEach(func);
      }
    };

    return Scene;

  })();
  Renderer = (function() {

    function Renderer(cv) {
      this.cv = cv;
      this.g = cv.getContext('2d');
      this.w = cv.width;
      this.h = cv.height;
    }

    Renderer.prototype.render = function(scene, camera) {
      var matProj;
      camera.updateProjectionMatrix();
      matProj = camera.getProjectionMatrix();
      this.g.beginPath();
      this.g.fillStyle = "rgba(0, 0, 0, 0.08)";
      this.g.fillRect(0, 0, this.w, this.h);
      return this.transformAndDraw(matProj, scene.materials);
    };

    /**
        Transform and draw.
        @param {M44} mat matrix.
        @param {Array} materials.
    */


    Renderer.prototype.transformAndDraw = function(mat, materials) {
      var g, m, out_list, r, results, uv_image, uv_list, vertex_list, w, weight, x, y, _i, _j, _len, _len1, _results;
      g = this.g;
      results = [];
      for (_i = 0, _len = materials.length; _i < _len; _i++) {
        m = materials[_i];
        if (m instanceof Mesh) {
          vertex_list = material.vertex;
          uv_image = material.texture.uv_data;
          uv_list = material.texture.uv_list;
          this.transformPoints(out_list, vertex_list, mat, this.w, this.h);
          drawTriangle(g, uv_image, out_list, uv_list);
        } else if (m instanceof Particle) {
          vertex_list = [m.v.x, m.v.y, m.v.z];
          out_list = new Array(6);
          this.transformPoints2(out_list, vertex_list, mat, this.w, this.h);
          x = out_list[0];
          y = out_list[1];
          w = out_list[2];
          weight = m.size / w;
          if (weight < 0) {
            continue;
          }
          results.push({
            material: m,
            x: x,
            y: y,
            w: w,
            r: m.r,
            g: m.g,
            b: m.b,
            weight: weight
          });
        }
      }
      results.sort(function(a, b) {
        return b.w - a.w;
      });
      _results = [];
      for (_j = 0, _len1 = results.length; _j < _len1; _j++) {
        r = results[_j];
        g.save();
        g.fillStyle = "rgba(" + r.r + ", " + r.g + ", " + r.b + ", " + r.weight + ")";
        g.beginPath();
        g.arc(r.x, r.y, r.weight, 0, ANGLE, true);
        g.closePath();
        g.fill();
        _results.push(g.restore());
      }
      return _results;
    };

    /**
        スクリーン座標変換
        Transform points
        @param {Array} out
        @param {Array} pts
        @param {M44} mat matrix
        @param {number} viewWidth
        @param {number} viewHeight
    
        計算された座標変換行列をスクリーンの座標系に変換するために計算する
        基本はスケーリング（&Y軸反転）と平行移動。
        行列で表すと
        w = width  / 2
        h = height / 2
        とすると
                    |w  0  0  0|
        M(screen) = |0 -h  0  0|
                    |0  0  1  0|
                    |w  h  0  1|
        以下の計算式で言うと、
    
        transformed_temp[0] *=  viewWidth
        transformed_temp[1] *= -viewHeight
        transformed_temp[0] +=  viewWidth  / 2
        transformed_temp[1] +=  viewHeight / 2
    
        となる。
    */


    Renderer.prototype.transformPoints = function(out, pts, mat, viewWidth, viewHeight) {
      var W, i, len, oi, transformed_temp, _h, _i, _results, _w;
      len = pts.length;
      transformed_temp = [0, 0, 0, 0];
      oi = 0;
      _w = viewWidth / 2;
      _h = viewHeight / 2;
      _results = [];
      for (i = _i = 0; _i < len; i = _i += 3) {
        mat.transVec3(transformed_temp, pts[i + 0], pts[i + 1], pts[i + 2]);
        W = transformed_temp[3];
        transformed_temp[0] /= W;
        transformed_temp[1] /= W;
        transformed_temp[2] /= W;
        transformed_temp[0] *= _w;
        transformed_temp[1] *= -_h;
        transformed_temp[0] += _w;
        transformed_temp[1] += _h;
        out[oi++] = transformed_temp[0];
        _results.push(out[oi++] = transformed_temp[1]);
      }
      return _results;
    };

    Renderer.prototype.transformPoints2 = function(out, pts, mat, viewWidth, viewHeight) {
      var W, oi, transformed_temp, _h, _w;
      transformed_temp = [0, 0, 0, 0];
      oi = 0;
      _w = viewWidth / 2;
      _h = viewHeight / 2;
      mat.transVec3(transformed_temp, pts[0], pts[1], pts[2]);
      W = transformed_temp[3];
      transformed_temp[0] /= W;
      transformed_temp[1] /= W;
      transformed_temp[2] /= W;
      transformed_temp[0] *= _w;
      transformed_temp[1] *= -_h;
      transformed_temp[0] += _w;
      transformed_temp[1] += _h;
      out[0] = transformed_temp[0];
      out[1] = transformed_temp[1];
      return out[2] = W;
    };

    return Renderer;

  })();
  /**
      Vector3 class
      @constructor
      @param {number} x Position of x.
      @param {number} y Position of y.
      @param {number} z Position of z.
  */

  Vector3 = (function() {

    function Vector3(x, y, z) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.z = z != null ? z : 0;
    }

    Vector3.prototype.zero = function() {
      return this.x = this.y = this.z = 0;
    };

    Vector3.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    };

    Vector3.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    };

    Vector3.prototype.copy = function(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    };

    Vector3.prototype.norm = function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };

    Vector3.prototype.normalize = function() {
      var nrm;
      nrm = this.norm();
      if (nrm !== 0) {
        this.x /= nrm;
        this.y /= nrm;
        this.z /= nrm;
      }
      return this;
    };

    Vector3.prototype.multiply = function(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    };

    Vector3.prototype.multiplyScalar = function(s) {
      this.x *= s;
      this.y *= s;
      this.z *= s;
      return this;
    };

    Vector3.prototype.multiplyVectors = function(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      return this.z = a.z * b.z;
    };

    Vector3.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    };

    Vector3.prototype.cross = function(v, w) {
      if (w) {
        return this.crossVector(v, w);
      }
      this.x = (this.y * v.z) - (this.z * v.y);
      this.y = (this.z * v.x) - (this.x * v.z);
      this.z = (this.x * v.y) - (this.y * v.x);
      return this;
    };

    Vector3.prototype.crossVector = function(v, w) {
      this.x = (w.y * v.z) - (w.z * v.y);
      this.y = (w.z * v.x) - (w.x * v.z);
      this.z = (w.x * v.y) - (w.y * v.x);
      return this;
    };

    Vector3.prototype.toString = function() {
      return "" + this.x + "," + this.y + "," + this.z;
    };

    return Vector3;

  })();
  Quaternion = (function() {

    function Quaternion(t, v) {
      this.t = t != null ? t : 0;
      this.v = v;
    }

    Quaternion.prototype.set = function(t, v) {
      this.t = t;
      this.v = v;
    };

    Quaternion.prototype.multiply = function(A) {
      return Quaternion.multiply(this, A);
    };

    Quaternion.multiply = function(A, B) {
      var Av, Bv, d1, d2, d3, d4, t, x, y, z;
      Av = A.v;
      Bv = B.v;
      d1 = A.t * B.t;
      d2 = -Av.x * Bv.x;
      d3 = -Av.y * Bv.y;
      d4 = -Av.z * Bv.z;
      t = parseFloat((d1 + d2 + d3 + d4).toFixed(5));
      d1 = (A.t * Bv.x) + (B.t * Av.x);
      d2 = (Av.y * Bv.z) - (Av.z * Bv.y);
      x = parseFloat((d1 + d2).toFixed(5));
      d1 = (A.t * Bv.y) + (B.t * Av.y);
      d2 = (Av.z * Bv.x) - (Av.x * Bv.z);
      y = parseFloat((d1 + d2).toFixed(5));
      d1 = (A.t * Bv.z) + (B.t * Av.z);
      d2 = (Av.x * Bv.y) - (Av.y * Bv.x);
      z = parseFloat((d1 + d2).toFixed(5));
      return new Quaternion(t, new Vector3(x, y, z));
    };

    return Quaternion;

  })();
  /**
      Make rotation quaternion
      @param {number} radian.
      @param {Vector3} vector.
  */

  makeRotatialQuaternion = function(radian, vector) {
    var axis, ccc, norm, ret, sss, t;
    ret = new Quaternion;
    ccc = 0;
    sss = 0;
    axis = new Vector3;
    axis.copy(vector);
    norm = vector.norm();
    if (norm <= 0.0) {
      return ret;
    }
    axis.normalize();
    ccc = cos(0.5 * radian);
    sss = sin(0.5 * radian);
    t = ccc;
    axis.multiplyScalar(sss);
    ret.set(t, axis);
    return ret;
  };
  /**
      M44 class
      @constructor
      @param {boolean} cpy
  */

  M44 = (function() {

    function M44(cpy) {
      if (cpy) {
        this.copy(cpy);
      } else {
        this.ident();
      }
    }

    M44.prototype.ident = function() {
      this._12 = this._13 = this._14 = 0;
      this._21 = this._23 = this._24 = 0;
      this._31 = this._32 = this._34 = 0;
      this._41 = this._42 = this._43 = 0;
      this._11 = this._22 = this._33 = this._44 = 1;
      return this;
    };

    /**
        Copy from `m`
        @param {M44} m
    */


    M44.prototype.copy = function(m) {
      this._11 = m._11;
      this._12 = m._12;
      this._13 = m._13;
      this._14 = m._14;
      this._21 = m._21;
      this._22 = m._22;
      this._23 = m._23;
      this._24 = m._24;
      this._31 = m._31;
      this._32 = m._32;
      this._33 = m._33;
      this._34 = m._34;
      this._41 = m._41;
      this._42 = m._42;
      this._43 = m._43;
      this._44 = m._44;
      return this;
    };

    /**
        4x4の変換行列を対象の1x4行列[x, y, z, 1]に適用する
        1x4行列と4x4行列の掛け算を行う
    
                    |@_11 @_12 @_13 @_14|
        |x y z 1| x |@_21 @_22 @_23 @_24|
                    |@_31 @_32 @_33 @_34|
                    |@_41 @_42 @_43 @_44|
    
        @_4nは1x4行列の最後が1のため、ただ足すだけになる
    
        @param {Array.<number>} out
        @param {number} x
        @param {number} y
        @param {number} z
    */


    M44.prototype.transVec3 = function(out, x, y, z) {
      out[0] = x * this._11 + y * this._21 + z * this._31 + this._41;
      out[1] = x * this._12 + y * this._22 + z * this._32 + this._42;
      out[2] = x * this._13 + y * this._23 + z * this._33 + this._43;
      return out[3] = x * this._14 + y * this._24 + z * this._34 + this._44;
    };

    M44.prototype.perspectiveLH = function(fov, aspect, near, far) {
      var tmp;
      tmp = M44.perspectiveLH(fov, aspect, near, far);
      return this.copy(tmp);
    };

    M44.perspectiveLH = function(fov, aspect, near, far) {
      var tmp, vh, vw, xmax, xmin, ymax, ymin, zoomX, zoomY;
      tmp = new M44;
      ymax = near * tan(fov * DEG_TO_RAD * 0.5);
      ymin = -ymax;
      xmin = ymin * aspect;
      xmax = ymax * aspect;
      vw = xmax - xmin;
      vh = ymax - ymin;
      zoomX = 2 * near / vw;
      zoomY = 2 * near / vh;
      tmp._11 = zoomX;
      tmp._12 = 0;
      tmp._13 = 0;
      tmp._14 = 0;
      tmp._21 = 0;
      tmp._22 = zoomY;
      tmp._23 = 0;
      tmp._24 = 0;
      tmp._31 = 0;
      tmp._32 = 0;
      tmp._33 = far + near / (far - near);
      tmp._34 = 1;
      tmp._41 = 0;
      tmp._42 = 0;
      tmp._43 = 2 * near * far / (near - far);
      tmp._44 = 0;
      return tmp;
    };

    M44.prototype.mul = function(A) {
      var tmp;
      tmp = M44.mul(this, A);
      this.copy(tmp);
      return this;
    };

    M44.mul = function(A, B) {
      var tmp;
      tmp = new M44;
      tmp._11 = A._11 * B._11 + A._12 * B._21 + A._13 * B._31 + A._14 * B._41;
      tmp._12 = A._11 * B._12 + A._12 * B._22 + A._13 * B._32 + A._14 * B._42;
      tmp._13 = A._11 * B._13 + A._12 * B._23 + A._13 * B._33 + A._14 * B._43;
      tmp._14 = A._11 * B._14 + A._12 * B._24 + A._13 * B._34 + A._14 * B._44;
      tmp._21 = A._21 * B._11 + A._22 * B._21 + A._23 * B._31 + A._24 * B._41;
      tmp._22 = A._21 * B._12 + A._22 * B._22 + A._23 * B._32 + A._24 * B._42;
      tmp._23 = A._21 * B._13 + A._22 * B._23 + A._23 * B._33 + A._24 * B._43;
      tmp._24 = A._21 * B._14 + A._22 * B._24 + A._23 * B._34 + A._24 * B._44;
      tmp._31 = A._31 * B._11 + A._32 * B._21 + A._33 * B._31 + A._34 * B._41;
      tmp._32 = A._31 * B._12 + A._32 * B._22 + A._33 * B._32 + A._34 * B._42;
      tmp._33 = A._31 * B._13 + A._32 * B._23 + A._33 * B._33 + A._34 * B._43;
      tmp._34 = A._31 * B._14 + A._32 * B._24 + A._33 * B._34 + A._34 * B._44;
      tmp._41 = A._41 * B._11 + A._42 * B._21 + A._43 * B._31 + A._44 * B._41;
      tmp._42 = A._41 * B._12 + A._42 * B._22 + A._43 * B._32 + A._44 * B._42;
      tmp._43 = A._41 * B._13 + A._42 * B._23 + A._43 * B._33 + A._44 * B._43;
      tmp._44 = A._41 * B._14 + A._42 * B._24 + A._43 * B._34 + A._44 * B._44;
      return tmp;
    };

    /**
        @param {Vector3} v
    */


    M44.prototype.translate = function(v) {
      var tmp;
      tmp = M44.translate(v);
      this.mul(tmp);
      return this;
    };

    /**
        translate by vector3
        @param {Vector3} v
    */


    M44.translate = function(v) {
      var tmp;
      tmp = new M44;
      tmp._11 = 1;
      tmp._12 = 0;
      tmp._13 = 0;
      tmp._14 = 0;
      tmp._21 = 0;
      tmp._22 = 1;
      tmp._23 = 0;
      tmp._24 = 0;
      tmp._31 = 0;
      tmp._32 = 0;
      tmp._33 = 1;
      tmp._34 = 0;
      tmp._41 = v.x;
      tmp._42 = v.y;
      tmp._43 = v.z;
      tmp._44 = 1;
      return tmp;
    };

    /**
        @param {number} r Rotate X
    */


    M44.prototype.rotX = function(r) {
      this._22 = cos(r);
      this._23 = sin(r);
      this._32 = -this._23;
      this._33 = this._22;
      this._12 = this._13 = this._14 = this._21 = this._24 = this._31 = this._34 = this._41 = this._42 = this._43 = 0;
      this._11 = this._44 = 1;
      return this;
    };

    /**
        @param {number} r Rotate Y
    */


    M44.prototype.rotY = function(r) {
      this._11 = cos(r);
      this._13 = -sin(r);
      this._31 = -this._13;
      this._33 = this._11;
      this._12 = this._14 = this._21 = this._23 = this._24 = this._32 = this._34 = this._41 = this._42 = this._43 = 0;
      this._22 = this._44 = 1;
      return this;
    };

    /**
        @param {number} r Rotate Z
    */


    M44.prototype.rotZ = function(r) {
      this._11 = cos(r);
      this._12 = sin(r);
      this._21 = -this._12;
      this._22 = this._11;
      this._13 = this._14 = this._23 = this._24 = this._31 = this._32 = this._34 = this._41 = this._42 = this._43 = 0;
      this._33 = this._44 = 1;
      return this;
    };

    return M44;

  })();
  /**
      M22 class
      @constructor
  */

  M22 = (function() {

    function M22() {
      this._11 = 1;
      this._12 = 0;
      this._21 = 0;
      this._22 = 1;
    }

    /**
        逆行列を生成
        
        [逆行列の公式]
    
        A = |a b|
            |c d|
    
        について、detA = ab - bc ≠0のときAの逆行列が存在する
    
        A^-1 = | d -b| * 1/ad-bc
               |-c  a|
    */


    M22.prototype.getInvert = function() {
      var det, out;
      out = new M22();
      det = this._11 * this._22 - this._12 * this._21;
      if ((0.0001 > det && det > -0.0001)) {
        return null;
      }
      out._11 = this._22 / det;
      out._22 = this._11 / det;
      out._12 = -this._12 / det;
      out._21 = -this._21 / det;
      return out;
    };

    return M22;

  })();
  exports.M44 = M44;
  exports.Camera = Camera;
  exports.Renderer = Renderer;
  exports.Scene = Scene;
  exports.Mesh = Mesh;
  exports.Particle = Particle;
  exports.Texture = Texture;
  exports.Vector3 = Vector3;
  return exports.Quaternion = Quaternion;
})(window, window.document, window);

(function(win, doc, exports) {
  var FAR, MOUSE_DOWN, MOUSE_MOVE, MOUSE_UP, PI, base, cHeight, cWidth, camera, cos, ctx, cv, dragging, draw, init, isTouch, particles, prevX, prevY, random, renderer, requestAnimFrame, rotX, rotY, rotZ, scene, sin, sqrt, startZoom, tan;
  sqrt = Math.sqrt, sin = Math.sin, cos = Math.cos, tan = Math.tan, PI = Math.PI, random = Math.random;
  isTouch = 'ontouchstart' in window;
  MOUSE_DOWN = isTouch ? 'touchstart' : 'mousedown';
  MOUSE_MOVE = isTouch ? 'touchmove' : 'mousemove';
  MOUSE_UP = isTouch ? 'touchend' : 'mouseup';
  requestAnimFrame = (function() {
    return win.requestAnimationFrame || win.mozRequestAnimationFrame || win.msRequestAnimationFrame || function(callback, element) {
      return win.setTimeout(callback, 16);
    };
  })();
  camera = null;
  scene = null;
  renderer = null;
  particles = [];
  cv = doc.querySelector('#canvas');
  ctx = cv.getContext('2d');
  cWidth = cv.width = win.innerWidth;
  cHeight = cv.height = win.innerHeight;
  FAR = 2000;
  rotX = 0;
  rotY = 0;
  rotZ = 0;
  dragging = false;
  prevX = 0;
  prevY = 0;
  init = function() {
    var b, g, hf, hh, hw, i, particle, r, size, sp, v, x, y, z, _i;
    camera = new Camera(90, cWidth / cHeight, 1, FAR);
    camera.position.z = 1000;
    scene = new Scene;
    renderer = new Renderer(cv);
    hw = cWidth / 2;
    hh = cHeight / 2;
    hf = FAR / 2;
    v = new Vector3(0, 0, 0);
    particle = new Particle(v, 0, 10000, 200, 200, 0);
    particles[0] = particle;
    scene.add(particle);
    for (i = _i = 1; _i < 300; i = ++_i) {
      x = ~~(random() * cWidth) - hw;
      y = ~~(random() * cHeight) - hh;
      z = ~~(random() * FAR) - hf;
      r = ~~(random() * 255);
      g = ~~(random() * 255);
      b = ~~(random() * 255);
      v = new Vector3(x, y, z);
      size = (~~(random() * FAR)) + 5;
      sp = random() * 2 + 0.1;
      particle = new Particle(v, sp, size, r, g, b);
      particles[i] = particle;
      scene.add(particle);
    }
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, cWidth, cHeight);
    return draw();
  };
  draw = function() {
    var p, _i, _len;
    for (_i = 0, _len = particles.length; _i < _len; _i++) {
      p = particles[_i];
      p.update();
    }
    renderer.render(scene, camera);
    return requestAnimFrame(draw);
  };
  win.addEventListener('mousewheel', function(e) {
    camera.position.z -= ~~(e.wheelDelta / 10);
    renderer.render(scene, camera);
    return e.preventDefault();
  }, false);
  base = 100;
  startZoom = 0;
  document.addEventListener('gesturechange', function(e) {
    var num;
    num = e.scale * base - base;
    return camera.position.z = startZoom - num;
  }, false);
  document.addEventListener('gesturestart', function() {
    return startZoom = camera.position.z;
  }, false);
  doc.addEventListener('touchstart', function(e) {
    return e.preventDefault();
  }, false);
  doc.addEventListener(MOUSE_DOWN, function(e) {
    dragging = true;
    prevX = isTouch ? e.touches[0].pageX : e.pageX;
    return prevY = isTouch ? e.touches[0].pageY : e.pageY;
  }, false);
  doc.addEventListener(MOUSE_MOVE, function(e) {
    var pageX, pageY;
    if (dragging === false) {
      return;
    }
    pageX = isTouch ? e.touches[0].pageX : e.pageX;
    pageY = isTouch ? e.touches[0].pageY : e.pageY;
    rotY += (prevX - pageX) / 100;
    rotX += (prevY - pageY) / 100;
    camera.setWorld(M44.mul((new M44()).rotY(rotY), (new M44()).rotX(rotX)));
    prevX = pageX;
    prevY = pageY;
    return renderer.render(scene, camera);
  }, false);
  doc.addEventListener(MOUSE_UP, function(e) {
    return dragging = false;
  }, false);
  return doc.addEventListener('DOMContentLoaded', init, false);
})(window, window.document, window);
