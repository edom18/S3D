//@ sourceMappingURL=TD.map
// Generated by CoffeeScript 1.6.1
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

(function(win, doc, exports) {
  var ANGLE, AmbientLight, Camera, Color, Cube, DEG_TO_RAD, DirectionalLight, Face, Light, Matrix2, Matrix4, Object3D, PI, Particle, Quaternion, Renderer, Scene, Texture, Triangle, Vector3, cos, drawTriangle, makeRotatialQuaternion, sin, sqrt, tan;
  sqrt = Math.sqrt, tan = Math.tan, cos = Math.cos, sin = Math.sin, PI = Math.PI;
  DEG_TO_RAD = PI / 180;
  ANGLE = PI * 2;
  drawTriangle = function(g, img, vertex_list, uv_list, vw, vh) {
    var Ax, Ay, Bx, By, a, b, c, d, height, hvh, hvw, m, me, mi, mie, width, x1, x2, x3, y1, y2, y3, z1, z2, z3, _Ax, _Ay, _Bx, _By;
    width = img.width;
    height = img.height;
    hvw = vw * 0.5;
    hvh = vh * 0.5;
    x1 = vertex_list[0] * hvw + hvw;
    y1 = vertex_list[1] * -hvh + hvh;
    z1 = vertex_list[2];
    x2 = vertex_list[3] * hvw + hvw;
    y2 = vertex_list[4] * -hvh + hvh;
    z2 = vertex_list[5];
    x3 = vertex_list[6] * hvw + hvw;
    y3 = vertex_list[7] * -hvh + hvh;
    z3 = vertex_list[8];
    _Ax = x2 - x1;
    _Ay = y2 - y1;
    _Bx = x3 - x1;
    _By = y3 - y1;
    if (((_Ax * (y3 - y2)) - (_Ay * (x3 - x2))) < 0) {
      return;
    }
    Ax = (uv_list[2] - uv_list[0]) * width;
    Ay = (uv_list[3] - uv_list[1]) * height;
    Bx = (uv_list[4] - uv_list[0]) * width;
    By = (uv_list[5] - uv_list[1]) * height;
    m = new Matrix2(Ax, Ay, Bx, By);
    me = m.elements;
    mi = m.getInvert();
    mie = mi.elements;
    if (!mi) {
      return;
    }
    a = mie[0] * _Ax + mie[2] * _Bx;
    c = mie[1] * _Ax + mie[3] * _Bx;
    b = mie[0] * _Ay + mie[2] * _By;
    d = mie[1] * _Ay + mie[3] * _By;
    g.save();
    g.beginPath();
    g.moveTo(x1, y1);
    g.lineTo(x2, y2);
    g.lineTo(x3, y3);
    g.clip();
    g.transform(a, b, c, d, x1 - (a * uv_list[0] * width + c * uv_list[1] * height), y1 - (b * uv_list[0] * width + d * uv_list[1] * height));
    g.drawImage(img, 0, 0);
    return g.restore();
  };
  /**
      Vector3 class
      @constructor
      @param {number} x Position of x.
      @param {number} y Position of y.
      @param {number} z Position of z.
  */

  Vector3 = (function() {

    function Vector3(x, y, z) {
      this.x = x != null ? x : 0;
      this.y = y != null ? y : 0;
      this.z = z != null ? z : 0;
    }

    Vector3.prototype.zero = function() {
      return this.x = this.y = this.z = 0;
    };

    Vector3.prototype.sub = function(v) {
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    };

    Vector3.prototype.subVectors = function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    };

    Vector3.prototype.add = function(v) {
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    };

    Vector3.prototype.copy = function(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    };

    Vector3.prototype.norm = function() {
      return sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    };

    Vector3.prototype.normalize = function() {
      var nrm;
      nrm = this.norm();
      if (nrm !== 0) {
        this.x /= nrm;
        this.y /= nrm;
        this.z /= nrm;
      }
      return this;
    };

    Vector3.prototype.multiply = function(v) {
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    };

    Vector3.prototype.multiplyScalar = function(s) {
      this.x *= s;
      this.y *= s;
      this.z *= s;
      return this;
    };

    Vector3.prototype.multiplyVectors = function(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      return this.z = a.z * b.z;
    };

    Vector3.prototype.dot = function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    };

    Vector3.prototype.cross = function(v, w) {
      if (w) {
        return this.crossVector(v, w);
      }
      this.x = (this.y * v.z) - (this.z * v.y);
      this.y = (this.z * v.x) - (this.x * v.z);
      this.z = (this.x * v.y) - (this.y * v.x);
      return this;
    };

    Vector3.prototype.crossVector = function(v, w) {
      this.x = (w.y * v.z) - (w.z * v.y);
      this.y = (w.z * v.x) - (w.x * v.z);
      this.z = (w.x * v.y) - (w.y * v.x);
      return this;
    };

    Vector3.prototype.applyMatrix4 = function(m) {
      var e, x, y, z;
      e = m.elements;
      x = this.x;
      y = this.y;
      z = this.z;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
      this.x = e[1] * x + e[5] * y + e[9] * z + e[13];
      this.x = e[2] * x + e[5] * y + e[10] * z + e[14];
      return this;
    };

    Vector3.prototype.applyProjection = function(m) {
      var e, w, x, y, z;
      x = this.x;
      y = this.y;
      z = this.z;
      e = m.elements;
      w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    };

    Vector3.prototype.clone = function() {
      var vec3;
      vec3 = new Vector3;
      vec3.copy(this);
      return vec3;
    };

    Vector3.prototype.toArray = function() {
      return [this.x, this.y, this.z];
    };

    Vector3.prototype.toString = function() {
      return "" + this.x + "," + this.y + "," + this.z;
    };

    return Vector3;

  })();
  /**
      Matrix2 class
      @constructor
  */

  Matrix2 = (function() {

    function Matrix2(m11, m12, m21, m22) {
      var te;
      if (m11 == null) {
        m11 = 1;
      }
      if (m12 == null) {
        m12 = 0;
      }
      if (m21 == null) {
        m21 = 0;
      }
      if (m22 == null) {
        m22 = 1;
      }
      this.elements = te = new Float32Array(4);
      te[0] = m11;
      te[2] = m12;
      te[1] = m21;
      te[3] = m22;
    }

    /**
        逆行列を生成
        
        [逆行列の公式]
    
        A = |a b|
            |c d|
    
        について、detA = ad - bc ≠0のときAの逆行列が存在する
    
        A^-1 = | d -b| * 1 / detA
               |-c  a|
    */


    Matrix2.prototype.getInvert = function() {
      var det, oe, out, te;
      out = new Matrix2();
      oe = out.elements;
      te = this.elements;
      det = te[0] * te[3] - te[2] * te[1];
      if ((0.0001 > det && det > -0.0001)) {
        return null;
      }
      oe[0] = te[3] / det;
      oe[1] = -te[1] / det;
      oe[2] = -te[2] / det;
      oe[3] = te[0] / det;
      return out;
    };

    return Matrix2;

  })();
  /**
      Matrix4 class
      @constructor
      @param {boolean} cpy
  */

  Matrix4 = (function() {

    function Matrix4(cpy) {
      this.elements = new Float32Array(16);
      if (cpy) {
        this.copy(cpy);
      } else {
        this.identity();
      }
    }

    Matrix4.prototype.identity = function() {
      var te;
      te = this.elements;
      te[0] = 1;
      te[4] = 0;
      te[8] = 0;
      te[12] = 0;
      te[1] = 0;
      te[5] = 1;
      te[9] = 0;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = 1;
      te[14] = 0;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    };

    Matrix4.prototype.getInvert = function() {
      var a11, a12, a13, a14, a21, a22, a23, a24, a31, a32, a33, a34, a41, a42, a43, a44, b11, b12, b13, b14, b21, b22, b23, b24, b31, b32, b33, b34, b41, b42, b43, b44, det, oe, out, te;
      out = new Matrix4;
      oe = out.elements;
      te = this.elements;
      a11 = te[0];
      a12 = te[4];
      a13 = te[8];
      a14 = te[12];
      a21 = te[1];
      a22 = te[5];
      a23 = te[9];
      a24 = te[13];
      a31 = te[2];
      a32 = te[6];
      a33 = te[10];
      a34 = te[14];
      a41 = te[3];
      a42 = te[7];
      a43 = te[11];
      a44 = te[15];
      det = (a11 * a22 * a33 * a44, +a11 * a23 * a34 * a42, +a11 * a24 * a32 * a43, +a12 * a21 * a34 * a43, +a12 * a23 * a31 * a44, +a12 * a24 * a33 * a41, +a13 * a21 * a32 * a44, +a13 * a22 * a34 * a41, +a13 * a24 * a31 * a42, +a14 * a21 * a33 * a42, +a14 * a22 * a31 * a43, +a14 * a23 * a32 * a41, -a11 * a22 * a34 * a43, -a11 * a23 * a32 * a44, -a11 * a24 * a33 * a42, -a12 * a21 * a33 * a44, -a12 * a23 * a34 * a41, -a12 * a24 * a31 * a43, -a13 * a21 * a34 * a42, -a13 * a22 * a31 * a44, -a13 * a24 * a32 * a41, -a14 * a21 * a32 * a43, -a14 * a22 * a33 * a41, -a14 * a23 * a31 * a42);
      if ((0.0001 > det && det > -0.0001)) {
        return null;
      }
      b11 = ((a22 * a33 * a44) + (a23 * a34 * a42) + (a24 * a32 * a43) - (a22 * a34 * a43) - (a23 * a32 * a44) - (a24 * a33 * a42)) / det;
      b12 = ((a12 * a34 * a43) + (a13 * a32 * a44) + (a14 * a33 * a42) - (a12 * a33 * a44) - (a13 * a34 * a42) - (a14 * a32 * a43)) / det;
      b13 = ((a12 * a23 * a44) + (a13 * a24 * a42) + (a14 * a22 * a43) - (a12 * a24 * a43) - (a13 * a22 * a44) - (a14 * a23 * a42)) / det;
      b14 = ((a12 * a24 * a33) + (a13 * a22 * a34) + (a14 * a23 * a32) - (a12 * a23 * a34) - (a13 * a24 * a32) - (a14 * a22 * a33)) / det;
      b21 = ((a21 * a34 * a43) + (a23 * a31 * a44) + (a24 * a33 * a41) - (a21 * a33 * a44) - (a23 * a34 * a41) - (a24 * a31 * a43)) / det;
      b22 = ((a11 * a33 * a44) + (a13 * a34 * a41) + (a14 * a31 * a43) - (a11 * a34 * a43) - (a13 * a31 * a44) - (a14 * a33 * a41)) / det;
      b23 = ((a11 * a24 * a43) + (a13 * a21 * a44) + (a14 * a23 * a41) - (a11 * a23 * a44) - (a13 * a24 * a41) - (a14 * a21 * a43)) / det;
      b24 = ((a11 * a23 * a34) + (a13 * a24 * a31) + (a14 * a21 * a33) - (a11 * a24 * a33) - (a13 * a21 * a34) - (a14 * a23 * a31)) / det;
      b31 = ((a21 * a32 * a44) + (a22 * a34 * a41) + (a24 * a31 * a42) - (a21 * a34 * a42) - (a22 * a31 * a44) - (a24 * a32 * a41)) / det;
      b32 = ((a11 * a34 * a42) + (a12 * a31 * a44) + (a14 * a32 * a41) - (a11 * a32 * a44) - (a12 * a34 * a41) - (a14 * a31 * a42)) / det;
      b33 = ((a11 * a22 * a44) + (a12 * a24 * a41) + (a14 * a21 * a42) - (a11 * a24 * a42) - (a12 * a21 * a44) - (a14 * a22 * a41)) / det;
      b34 = ((a11 * a24 * a32) + (a12 * a21 * a34) + (a14 * a22 * a31) - (a11 * a22 * a34) - (a12 * a24 * a31) - (a14 * a21 * a32)) / det;
      b41 = ((a21 * a33 * a42) + (a22 * a31 * a43) + (a23 * a32 * a41) - (a21 * a32 * a43) - (a22 * a33 * a41) - (a23 * a31 * a42)) / det;
      b42 = ((a11 * a32 * a43) + (a12 * a33 * a41) + (a13 * a31 * a42) - (a11 * a33 * a42) - (a12 * a31 * a43) - (a13 * a32 * a41)) / det;
      b43 = ((a11 * a23 * a42) + (a12 * a21 * a43) + (a13 * a22 * a41) - (a11 * a22 * a43) - (a12 * a23 * a41) - (a13 * a21 * a42)) / det;
      b44 = ((a11 * a22 * a33) + (a12 * a23 * a31) + (a13 * a21 * a32) - (a11 * a23 * a32) - (a12 * a21 * a33) - (a13 * a22 * a31)) / det;
      oe[0] = b11;
      oe[4] = b12;
      oe[8] = b13;
      oe[12] = b14;
      oe[1] = b21;
      oe[5] = b22;
      oe[9] = b23;
      oe[13] = b24;
      oe[2] = b31;
      oe[6] = b32;
      oe[10] = b33;
      oe[14] = b34;
      oe[3] = b41;
      oe[7] = b42;
      oe[11] = b43;
      oe[15] = b44;
      return out;
    };

    /**
        Copy from `m`
        @param {Matrix4} m
    */


    Matrix4.prototype.copy = function(m) {
      var me, te;
      te = this.elements;
      me = m.elements;
      te[0] = me[0];
      te[4] = me[4];
      te[8] = me[8];
      te[12] = me[12];
      te[1] = me[1];
      te[5] = me[5];
      te[9] = me[9];
      te[13] = me[13];
      te[2] = me[2];
      te[6] = me[6];
      te[10] = me[10];
      te[14] = me[14];
      te[3] = me[3];
      te[7] = me[7];
      te[11] = me[11];
      te[15] = me[15];
      return this;
    };

    /**
        4x4の変換行列を対象の1x4行列[x, y, z, 1]に適用する
        1x4行列と4x4行列の掛け算を行う
    
                    |@_11 @_12 @_13 @_14|
        |x y z 1| x |@_21 @_22 @_23 @_24|
                    |@_31 @_32 @_33 @_34|
                    |@_41 @_42 @_43 @_44|
    
        @_4nは1x4行列の最後が1のため、ただ足すだけになる
    
        @param {Array.<number>} out
        @param {number} x
        @param {number} y
        @param {number} z
    */


    Matrix4.prototype.transVec3 = function(out, x, y, z) {
      var te;
      te = this.elements;
      out[0] = te[0] * x + te[4] * y + te[8] * z + te[12];
      out[1] = te[1] * x + te[5] * y + te[9] * z + te[13];
      out[2] = te[2] * x + te[6] * y + te[10] * z + te[14];
      return out[3] = te[3] * x + te[7] * y + te[11] * z + te[15];
    };

    Matrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {
      var te, vh, vw, w, x, y, z;
      te = this.elements;
      vw = right - left;
      vh = top - bottom;
      x = 2 * near / vw;
      y = 2 * near / vh;
      z = -(far + near) / (far - near);
      w = -(2 * near * far) / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = 0;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = 0;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = z;
      te[14] = w;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    };

    Matrix4.prototype.perspectiveLH = function(fov, aspect, near, far) {
      var tmp;
      tmp = Matrix4.perspectiveLH(fov, aspect, near, far);
      return this.copy(tmp);
    };

    Matrix4.perspectiveLH = function(fov, aspect, near, far) {
      var te, tmp, xmax, xmin, ymax, ymin;
      tmp = new Matrix4;
      te = tmp.elements;
      ymax = near * tan(fov * DEG_TO_RAD * 0.5);
      ymin = -ymax;
      xmin = ymin * aspect;
      xmax = ymax * aspect;
      return tmp.makeFrustum(xmin, xmax, ymin, ymax, near, far);
    };

    Matrix4.prototype.multiply = function(A) {
      var tmp;
      tmp = Matrix4.multiply(this, A);
      this.copy(tmp);
      return this;
    };

    Matrix4.multiply = function(A, B) {
      var A11, A12, A13, A14, A21, A22, A23, A24, A31, A32, A33, A34, A41, A42, A43, A44, B11, B12, B13, B14, B21, B22, B23, B24, B31, B32, B33, B34, B41, B42, B43, B44, ae, be, te, tmp;
      ae = A.elements;
      be = B.elements;
      A11 = ae[0];
      A12 = ae[4];
      A13 = ae[8];
      A14 = ae[12];
      A21 = ae[1];
      A22 = ae[5];
      A23 = ae[9];
      A24 = ae[13];
      A31 = ae[2];
      A32 = ae[6];
      A33 = ae[10];
      A34 = ae[14];
      A41 = ae[3];
      A42 = ae[7];
      A43 = ae[11];
      A44 = ae[15];
      B11 = be[0];
      B12 = be[4];
      B13 = be[8];
      B14 = be[12];
      B21 = be[1];
      B22 = be[5];
      B23 = be[9];
      B24 = be[13];
      B31 = be[2];
      B32 = be[6];
      B33 = be[10];
      B34 = be[14];
      B41 = be[3];
      B42 = be[7];
      B43 = be[11];
      B44 = be[15];
      tmp = new Matrix4;
      te = tmp.elements;
      te[0] = A11 * B11 + A12 * B21 + A13 * B31 + A14 * B41;
      te[4] = A11 * B12 + A12 * B22 + A13 * B32 + A14 * B42;
      te[8] = A11 * B13 + A12 * B23 + A13 * B33 + A14 * B43;
      te[12] = A11 * B14 + A12 * B24 + A13 * B34 + A14 * B44;
      te[1] = A21 * B11 + A22 * B21 + A23 * B31 + A24 * B41;
      te[5] = A21 * B12 + A22 * B22 + A23 * B32 + A24 * B42;
      te[9] = A21 * B13 + A22 * B23 + A23 * B33 + A24 * B43;
      te[13] = A21 * B14 + A22 * B24 + A23 * B34 + A24 * B44;
      te[2] = A31 * B11 + A32 * B21 + A33 * B31 + A34 * B41;
      te[6] = A31 * B12 + A32 * B22 + A33 * B32 + A34 * B42;
      te[10] = A31 * B13 + A32 * B23 + A33 * B33 + A34 * B43;
      te[14] = A31 * B14 + A32 * B24 + A33 * B34 + A34 * B44;
      te[3] = A41 * B11 + A42 * B21 + A43 * B31 + A44 * B41;
      te[7] = A41 * B12 + A42 * B22 + A43 * B32 + A44 * B42;
      te[11] = A41 * B13 + A42 * B23 + A43 * B33 + A44 * B43;
      te[15] = A41 * B14 + A42 * B24 + A43 * B34 + A44 * B44;
      return tmp;
    };

    /**
        Multiply Matrices
        A, Bふたつの行列の掛け算した結果をthisに保存
        @param {Matrix4} A.
        @param {Matrix4} B.
    */


    Matrix4.prototype.multiplyMatrices = function(A, B) {
      var tmp;
      tmp = Matrix4.multiply(A, B);
      this.copy(tmp);
      return this;
    };

    /**
        @param {Vector3} v
    */


    Matrix4.prototype.translate = function(v) {
      var te, x, y, z;
      te = this.elements;
      x = v.x;
      y = v.y;
      z = v.z;
      te[12] = te[0] * x + te[4] * y + te[8] * z + te[12];
      te[13] = te[1] * x + te[5] * y + te[9] * z + te[13];
      te[14] = te[2] * x + te[6] * y + te[10] * z + te[14];
      te[15] = te[3] * x + te[7] * y + te[11] * z + te[15];
      return this;
    };

    /**
        @param {Vector3} eye
        @param {Vector3} target
        @param {Vector3} up
    */


    Matrix4.prototype.lookAt = (function() {
      var x, y, z;
      x = new Vector3;
      y = new Vector3;
      z = new Vector3;
      return function(eye, target, up) {
        var te, tx, ty, tz;
        te = this.elements;
        z.subVectors(eye, target).normalize();
        x.crossVector(up, z).normalize();
        y.crossVector(z, x).normalize();
        tx = eye.dot(x);
        ty = eye.dot(y);
        tz = eye.dot(z);
        te[0] = x.x;
        te[4] = x.y;
        te[8] = x.z;
        te[12] = -tx;
        te[1] = y.x;
        te[5] = y.y;
        te[9] = y.z;
        te[13] = -ty;
        te[2] = z.x;
        te[6] = z.y;
        te[10] = z.z;
        te[14] = -tz;
        return this;
      };
    })();

    /**
        @param {number} r Rotate X
    */


    Matrix4.prototype.rotX = function(r) {
      var c, s, te;
      te = this.elements;
      c = cos(r);
      s = sin(r);
      te[0] = 1;
      te[4] = 0;
      te[8] = 0;
      te[12] = 0;
      te[1] = 0;
      te[5] = c;
      te[9] = -s;
      te[13] = 0;
      te[2] = 0;
      te[6] = s;
      te[10] = c;
      te[14] = 0;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    };

    /**
        @param {number} r Rotate Y
    */


    Matrix4.prototype.rotY = function(r) {
      var c, s, te;
      te = this.elements;
      c = cos(r);
      s = sin(r);
      te[0] = c;
      te[4] = 0;
      te[8] = s;
      te[12] = 0;
      te[1] = 0;
      te[5] = 1;
      te[9] = 0;
      te[13] = 0;
      te[2] = -s;
      te[6] = 0;
      te[10] = c;
      te[14] = 0;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    };

    /**
        @param {number} r Rotate Z
    */


    Matrix4.prototype.rotZ = function(r) {
      var c, s, te;
      te = this.elements;
      c = cos(r);
      s = sin(r);
      te[0] = c;
      te[4] = -s;
      te[8] = 0;
      te[12] = 0;
      te[1] = s;
      te[5] = c;
      te[9] = 0;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = 1;
      te[14] = 0;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    };

    return Matrix4;

  })();
  Object3D = (function() {

    function Object3D() {
      this.parent = null;
      this.children = [];
      this.position = new Vector3;
      this.rotation = new Vector3;
      this.scale = new Vector3(1, 1, 1);
      this.up = new Vector3(0, 1, 0);
      this.matrix = new Matrix4;
      this.matrixWorld = new Matrix4;
    }

    Object3D.prototype.updateMatrix = function() {
      var c, _i, _len, _ref, _results;
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c.updateMatrix());
      }
      return _results;
    };

    Object3D.prototype.updateMatrixWorld = function() {
      var c, _i, _len, _ref, _results;
      if (!this.parent) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      _ref = this.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c.updateMatrixWorld());
      }
      return _results;
    };

    Object3D.prototype.localToWorld = function(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    };

    Object3D.prototype.add = function(object) {
      var _ref;
      if (this === object) {
        return null;
      }
      if ((_ref = object.parent) != null) {
        _ref.remove(object);
      }
      this.children.push(object);
      return object.parent = this;
    };

    Object3D.prototype.remove = function(object) {
      var index, ret;
      if (this === object) {
        return null;
      }
      index = this.children.indexOf(object);
      if (index === -1) {
        return null;
      }
      return ret = this.children.splice(index, 1);
    };

    return Object3D;

  })();
  /**
      Camera class
      @constructor
      @param {number} fov Field of view.
      @param {number} aspect Aspect ratio.
      @param {number} near Near clip.
      @param {number} far far clip.
      @param {Vector3} position Position vector.
  */

  Camera = (function(_super) {

    __extends(Camera, _super);

    function Camera(fov, aspect, near, far, position) {
      this.fov = fov;
      this.aspect = aspect;
      this.near = near;
      this.far = far;
      this.position = position != null ? position : new Vector3(0, 0, 20);
      Camera.__super__.constructor.apply(this, arguments);
      this.viewMatrix = new Matrix4;
      this.projectionMatrix = new Matrix4;
      this.updateProjectionMatrix();
    }

    Camera.prototype.setWorld = function(m) {
      return this.matrixWorld = m;
    };

    Camera.prototype.getProjectionMatrix = function() {
      var tmp;
      tmp = Matrix4.multiply(this.projectionMatrix, this.viewMatrix);
      return Matrix4.multiply(tmp, this.matrixWorld);
    };

    Camera.prototype.updateProjectionMatrix = function() {
      this.lookAt();
      return this.projectionMatrix.perspectiveLH(this.fov, this.aspect, this.near, this.far);
    };

    Camera.prototype.lookAt = (function() {
      var m1;
      m1 = new Matrix4;
      return function(vector) {
        this.vector = vector || this.vector || new Vector3;
        m1.lookAt(this.position, this.vector, this.up);
        return this.viewMatrix.copy(m1);
      };
    })();

    return Camera;

  })(Object3D);
  Face = (function(_super) {

    __extends(Face, _super);

    function Face(x1, y1, x2, y2, img, uvData1, uvData2) {
      var texture1, texture2, triangle1, triangle2;
      Face.__super__.constructor.apply(this, arguments);
      texture1 = new Texture(img, uvData1);
      triangle1 = new Triangle([x1, y1, 0, x2, y1, 0, x1, y2, 0], texture1);
      this.add(triangle1);
      texture2 = new Texture(img, uvData2);
      triangle2 = new Triangle([x1, y2, 0, x2, y1, 0, x2, y2, 0], texture2);
      this.add(triangle2);
    }

    return Face;

  })(Object3D);
  Triangle = (function(_super) {

    __extends(Triangle, _super);

    function Triangle(vertices, texture) {
      var i, v, vec3, _i, _len;
      this.texture = texture;
      Triangle.__super__.constructor.apply(this, arguments);
      this.vertices = [];
      for (i = _i = 0, _len = vertices.length; _i < _len; i = _i += 3) {
        v = vertices[i];
        vec3 = new Vector3(vertices[i + 0], vertices[i + 1], vertices[i + 2]);
        this.vertices.push(vec3);
      }
    }

    Triangle.prototype.getVerticesByProjectionMatrix = function(m) {
      var ret, v, _i, _len, _ref;
      ret = [];
      _ref = this.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        ret = ret.concat(v.clone().applyProjection(m).toArray());
      }
      return ret;
    };

    return Triangle;

  })(Object3D);
  Cube = (function(_super) {

    __extends(Cube, _super);

    function Cube(w, h, p, sx, sy, sz, materials) {
      var i, triangle, _i;
      Cube.__super__.constructor.apply(this, arguments);
      w *= 0.5;
      h *= 0.5;
      p *= 0.5;
      for (i = _i = 0; _i < 12; i = ++_i) {
        triangle = new Triangle([-w, h, p, w, h, p, -w, -h, p], new Texture(materials[0].uv_data, [0, 0, 0.5, 0, 0, 0.5]));
        this.add(triangle);
      }
    }

    return Cube;

  })(Object3D);
  Texture = (function() {

    function Texture(uv_data, uv_list) {
      this.uv_data = uv_data;
      this.uv_list = uv_list;
    }

    return Texture;

  })();
  Particle = (function() {

    function Particle(v, sp, size, r, g, b) {
      this.v = v;
      this.sp = sp != null ? sp : 1;
      this.size = size != null ? size : 1000;
      this.r = r != null ? r : 255;
      this.g = g != null ? g : 255;
      this.b = b != null ? b : 255;
      this.vec = new Vector3(1, 0, 1);
    }

    Particle.prototype.update = function() {
      var p, q, r, rad;
      p = new Quaternion(0, this.v);
      rad = this.sp * DEG_TO_RAD;
      q = makeRotatialQuaternion(rad, this.vec);
      r = makeRotatialQuaternion(-rad, this.vec);
      p = r.multiply(p);
      p = p.multiply(q);
      return this.v = p.v;
    };

    return Particle;

  })();
  Color = (function() {

    function Color(r, g, b, a) {
      this.r = r;
      this.g = g;
      this.b = b;
      this.a = a;
    }

    return Color;

  })();
  Light = (function() {

    function Light(color) {
      this.color = color;
    }

    return Light;

  })();
  AmbientLight = (function(_super) {

    __extends(AmbientLight, _super);

    function AmbientLight(color) {
      this.color = color;
      AmbientLight.__super__.constructor.apply(this, arguments);
    }

    return AmbientLight;

  })(Light);
  DirectionalLight = (function(_super) {

    __extends(DirectionalLight, _super);

    function DirectionalLight(color) {
      this.color = color;
      DirectionalLight.__super__.constructor.apply(this, arguments);
    }

    return DirectionalLight;

  })(Light);
  Scene = (function() {

    function Scene() {
      this.materials = [];
    }

    Scene.prototype.add = function(material) {
      return this.materials.push(material);
    };

    Scene.prototype.sort = function(func) {
      if (func) {
        return this.materials.sort(func);
      }
    };

    Scene.prototype.each = function(func) {
      if (func) {
        return this.materials.forEach(func);
      }
    };

    return Scene;

  })();
  Renderer = (function() {

    function Renderer(cv, clearColor) {
      this.cv = cv;
      this.clearColor = clearColor != null ? clearColor : '#fff';
      this.g = cv.getContext('2d');
      this.w = cv.width;
      this.h = cv.height;
    }

    Renderer.prototype.render = function(scene, camera) {
      var matProj;
      camera.updateProjectionMatrix();
      matProj = camera.getProjectionMatrix();
      this.g.beginPath();
      this.g.fillStyle = this.clearColor;
      this.g.fillRect(0, 0, this.w, this.h);
      return this.transformAndDraw(matProj, scene.materials);
    };

    /**
        Transform and draw.
        @param {Matrix4} mat matrix.
        @param {Array} materials.
    */


    Renderer.prototype.transformAndDraw = function(mat, materials) {
      var c, g, m, out_list, r, results, uv_image, uv_list, vertex_list, w, weight, x, y, _i, _j, _k, _len, _len1, _len2, _ref, _results;
      g = this.g;
      results = [];
      out_list = [];
      for (_i = 0, _len = materials.length; _i < _len; _i++) {
        m = materials[_i];
        out_list = [];
        if (m instanceof Triangle) {
          vertex_list = m.getVerticesByProjectionMatrix(mat);
          uv_image = m.texture.uv_data;
          uv_list = m.texture.uv_list;
          drawTriangle(g, uv_image, vertex_list, uv_list, this.w, this.h);
        } else if (m instanceof Cube) {
          _ref = m.children;
          for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
            c = _ref[_j];
            out_list = [];
            vertex_list = c.vertex;
            uv_image = c.texture.uv_data;
            uv_list = c.texture.uv_list;
            this.transformPoints(out_list, vertex_list, mat, this.w, this.h);
            drawTriangle(g, uv_image, out_list, uv_list);
          }
        } else if (m instanceof Particle) {
          vertex_list = [m.v.x, m.v.y, m.v.z];
          this.transformPoints(out_list, vertex_list, mat, this.w, this.h);
          x = out_list[0];
          y = out_list[1];
          w = out_list[2];
          weight = m.size / w;
          if (weight < 0) {
            continue;
          }
          results.push({
            material: m,
            x: x,
            y: y,
            w: w,
            r: m.r,
            g: m.g,
            b: m.b,
            weight: weight
          });
        }
      }
      results.sort(function(a, b) {
        return b.w - a.w;
      });
      _results = [];
      for (_k = 0, _len2 = results.length; _k < _len2; _k++) {
        r = results[_k];
        g.save();
        g.fillStyle = "rgba(" + r.r + ", " + r.g + ", " + r.b + ", " + r.weight + ")";
        g.beginPath();
        g.arc(r.x, r.y, r.weight, 0, ANGLE, true);
        g.closePath();
        g.fill();
        _results.push(g.restore());
      }
      return _results;
    };

    /**
        スクリーン座標変換
        Transform points
        @param {Array} out
        @param {Array} pts
        @param {Matrix4} mat matrix
        @param {number} viewWidth
        @param {number} viewHeight
    
        計算された座標変換行列をスクリーンの座標系に変換するために計算する
        基本はスケーリング（&Y軸反転）と平行移動。
        行列で表すと
        w = width  / 2
        h = height / 2
        とすると
                    |w  0  0  0|
        M(screen) = |0 -h  0  0|
                    |0  0  1  0|
                    |w  h  0  1|
        以下の計算式で言うと、
    
        transformed_temp[0] *=  viewWidth
        transformed_temp[1] *= -viewHeight
        transformed_temp[0] +=  viewWidth  / 2
        transformed_temp[1] +=  viewHeight / 2
    
        となる。
    */


    Renderer.prototype.transformPoints = function(out, pts, mat, viewWidth, viewHeight) {
      var W, i, len, oi, transformed_temp, _h, _i, _results, _w;
      len = pts.length;
      transformed_temp = [0, 0, 0, 0];
      oi = 0;
      _w = viewWidth / 2;
      _h = viewHeight / 2;
      _results = [];
      for (i = _i = 0; _i < len; i = _i += 3) {
        mat.transVec3(transformed_temp, pts[i + 0], pts[i + 1], pts[i + 2]);
        W = transformed_temp[3];
        transformed_temp[0] /= W;
        transformed_temp[1] /= W;
        transformed_temp[2] /= W;
        transformed_temp[0] *= _w;
        transformed_temp[1] *= -_h;
        transformed_temp[0] += _w;
        transformed_temp[1] += _h;
        out[oi++] = transformed_temp[0];
        out[oi++] = transformed_temp[1];
        _results.push(out[oi++] = W);
      }
      return _results;
    };

    return Renderer;

  })();
  Quaternion = (function() {

    function Quaternion(t, v) {
      this.t = t != null ? t : 0;
      this.v = v;
    }

    Quaternion.prototype.set = function(t, v) {
      this.t = t;
      this.v = v;
    };

    Quaternion.prototype.multiply = function(A) {
      return Quaternion.multiply(this, A);
    };

    Quaternion.multiply = function(A, B) {
      var Av, Bv, d1, d2, d3, d4, t, x, y, z;
      Av = A.v;
      Bv = B.v;
      d1 = A.t * B.t;
      d2 = -Av.x * Bv.x;
      d3 = -Av.y * Bv.y;
      d4 = -Av.z * Bv.z;
      t = parseFloat((d1 + d2 + d3 + d4).toFixed(5));
      d1 = (A.t * Bv.x) + (B.t * Av.x);
      d2 = (Av.y * Bv.z) - (Av.z * Bv.y);
      x = parseFloat((d1 + d2).toFixed(5));
      d1 = (A.t * Bv.y) + (B.t * Av.y);
      d2 = (Av.z * Bv.x) - (Av.x * Bv.z);
      y = parseFloat((d1 + d2).toFixed(5));
      d1 = (A.t * Bv.z) + (B.t * Av.z);
      d2 = (Av.x * Bv.y) - (Av.y * Bv.x);
      z = parseFloat((d1 + d2).toFixed(5));
      return new Quaternion(t, new Vector3(x, y, z));
    };

    return Quaternion;

  })();
  /**
      Make rotation quaternion
      @param {number} radian.
      @param {Vector3} vector.
  */

  makeRotatialQuaternion = function(radian, vector) {
    var axis, ccc, norm, ret, sss, t;
    ret = new Quaternion;
    ccc = 0;
    sss = 0;
    axis = new Vector3;
    axis.copy(vector);
    norm = vector.norm();
    if (norm <= 0.0) {
      return ret;
    }
    axis.normalize();
    ccc = cos(0.5 * radian);
    sss = sin(0.5 * radian);
    t = ccc;
    axis.multiplyScalar(sss);
    ret.set(t, axis);
    return ret;
  };
  exports.Matrix2 = Matrix2;
  exports.Matrix4 = Matrix4;
  exports.Camera = Camera;
  exports.Renderer = Renderer;
  exports.Scene = Scene;
  exports.Texture = Texture;
  exports.Face = Face;
  exports.Triangle = Triangle;
  exports.Cube = Cube;
  exports.Particle = Particle;
  exports.Texture = Texture;
  exports.Vector3 = Vector3;
  return exports.Quaternion = Quaternion;
})(window, window.document, window.S3D || (window.S3D = {}));
